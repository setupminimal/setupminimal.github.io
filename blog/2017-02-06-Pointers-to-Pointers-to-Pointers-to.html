<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/typesetter.css">
    <title>Pointers to Pointers to Pointers to  | Setupminimal</title>
  </head>
  <body>
    <nav>
      You're reading 2017-02-06-Pointers-to-Pointers-to-Pointers-to.html. This site was last regenerated on Tuesday, January 5th, 2021.
      <ul>
      <li><a href="/index.html">Home</a></li>
      <li><a href="/blog.html">Blog</a></li>
      <li><a href="/resume.html">Resum√©</a></li>
      <li><a href="/fiction.html">Fiction</a></li>
      </ul>
    </nav>
    <root><h1 id="pointers-to-pointers-to-pointers-to-">Pointers to Pointers to Pointers to &hellip;</h1><p>This week both CS515 and CS520 covered how to use C++ and C, respectively, to do things involving data.</p><p>C++ is a super-set of C - that is, if a program is valid C code, it is also valid C++ code. Luckily, this means that many of the same concepts apply equally well to both classes footnote:[Which is why I&rsquo;m writing about them together.]. The main concept this week is the idea of memory, and how things are laid out in memory.</p><h3 id="memory">Memory</h3><p>Physically, a computer uses a big block of logic gates that can store some state representing a Boolean value. So the first logic gate might have a 0, the second a 1, the third another 0, and so on. Let&rsquo;s imagine that we had this segment of memory:</p><hr/><h2 id="">&hellip;01000001&hellip;</h2><p>What does this represent? Well, it might represent the number 65, expressed in base 2. It might represent the letter &lsquo;A&rsquo;. It might represent the number &ndash;191 represented in two&rsquo;s-complement form. It might be part of a larger number. It could even be a gray-ish part of a pixel.</p><p>The meaning of the bits represented inside the computer depends on their interpretation. Which leads to a bunch of cool things, including:</p><h3 id="pointers">Pointers</h3><p>A pointer is just a bit of memory which stores the location of something else in memory. So, for example, an <code>int *</code> footnote:[Pronounced &lsquo;int pointer&rsquo;.] in C means &lsquo;a value which points to the location of an integer&rsquo;. An <code>int **</code> footnote:[Pronounced &lsquo;int pointer pointer&rsquo;] points to the location of an <code>int *</code>.</p><p>Why is this important? Because it provides a fast way for different parts of a program to communicate, as well as providing a way to refer to big structures in memory using only a single number. To understand how pointers help with that, let&rsquo;s take a look at Casting.</p><h3 id="casting">Casting</h3><p>Since <code>01000001</code> could mean either 65 or &lsquo;A&rsquo;, we can go back and forth between those two values not by changing the physical memory, but just by changing our <em>interpretation</em> of that memory. For example, <code>'A' + 1 == 'B'</code>. We think of &lsquo;A&rsquo; as a number (65), add 1 (66), and then think of the result as a letter (&lsquo;B&rsquo;).</p><p>How is this relevant to pointers? Well, let&rsquo;s imagine that we have an <code>int *</code>. Since an <code>int *</code> is just a number stored in memory (like everything is), we can do math on it. So lets take our pointer and add 1 to it. Now what? Now the pointer points to the <em>next item in memory</em>. footnote:[Well, actually to the next byte in memory. If your object is bigger than a byte, then you need to add more than one to the pointer to find the next one.] How cool is that?</p><p>We can use this ability to do math with pointers to create arrays. Just keep a pointer to the first item. Then, to look up the 3rd item, just add 2 to the pointer and look there. In fact, the syntax for accessing a particular item of an array (<code>array[index]</code>) is translated by the compiler into <code>array + (index * size-of-an-item-in-the-array)</code>, because <code>array</code> is just a pointer.</p><h3 id="so-what">So What?</h3><p>So why is all this actually useful? That&rsquo;s a good question, and one that I don&rsquo;t have a <em>complete</em> answer for yet. What I have done so far, however, is write a program that can convert from UTF&ndash;8 to UTF&ndash;32 by reading in the UTF&ndash;8 file into memory, and then reinterpreting each of the letters as an item to write out in UTF&ndash;32, so that&rsquo;s pretty neat.</p><p>I hope to see you next week for more computer science!</p></root>
  </body>
</html>